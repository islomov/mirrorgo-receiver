<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MirrorGo Receiver</title>
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: black;
            overflow: hidden;
        }
        #mirrorImage {
            position: absolute;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        #status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #9333EA;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 32px;
            text-align: center;
            z-index: 1000;
        }
        #status.connected {
            top: 20px;
            left: 20px;
            transform: none;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="status">MirrorGo<br><span style="font-size: 18px;">Waiting for connection...</span></div>
    <img id="mirrorImage" src="" alt="Screen Mirror">

    <script>
        const NAMESPACE = 'urn:x-cast:com.mirrorgo.stream';

        const context = cast.framework.CastReceiverContext.getInstance();
        const mirrorImage = document.getElementById('mirrorImage');
        const status = document.getElementById('status');

        let streamUrl = null;
        let frameCount = 0;
        let isStreaming = false;

        function showStatus(msg) {
            console.log('MirrorGo: ' + msg);
            status.innerHTML = 'MirrorGo<br><span style="font-size: 18px;">' + msg + '</span>';
        }

        function showConnected() {
            status.className = 'connected';
            status.textContent = 'MirrorGo: Streaming';
            setTimeout(function() { status.style.opacity = '0.5'; }, 3000);
        }

        function setImgSrc() {
            if (!streamUrl || !isStreaming) return;
            var currentTime = new Date().getTime();
            mirrorImage.src = streamUrl + '?time=' + currentTime;
        }

        mirrorImage.onload = function() {
            frameCount++;
            if (frameCount === 1) {
                mirrorImage.style.display = 'block';
                showConnected();
            }
            setImgSrc();
        };

        mirrorImage.onerror = function() {
            setTimeout(setImgSrc, 100);
        };

        context.addCustomMessageListener(NAMESPACE, function(event) {
            console.log('MirrorGo: Received message:', event.data);

            try {
                const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

                if (data.type === 'START_STREAM' && data.url) {
                    streamUrl = data.url;
                    isStreaming = true;
                    frameCount = 0;
                    showStatus('Connecting to stream...');
                    console.log('MirrorGo: Starting stream from:', streamUrl);
                    setImgSrc();
                } else if (data.type === 'STOP_STREAM') {
                    isStreaming = false;
                    streamUrl = null;
                    mirrorImage.style.display = 'none';
                    status.className = '';
                    showStatus('Stream stopped');
                }
            } catch (e) {
                console.error('MirrorGo: Error parsing message:', e);
            }
        });

        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = true;
        options.maxInactivity = 3600;
        options.customNamespaces = {};
        options.customNamespaces[NAMESPACE] = cast.framework.system.MessageType.JSON;

        showStatus('Waiting for connection...');
        context.start(options);
    </script>
</body>
</html>
